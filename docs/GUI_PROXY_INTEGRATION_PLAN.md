# ☕️ GUI + Proxy API Интеграция: Контекст и Пошаговый План

**Дата:** 17 октября 2025  
**Проект:** `Granit DB analize sales` (GUI‑анализатор продаж кофе)  
**Цель:** добавить третий безопасный способ доступа к БД через REST API (`Firebird Database Proxy API`) без риска повредить данные или существующую функциональность.

---

## 1. Текущий контекст проекта

### 1.1. Существующие режимы подключения в GUI
- `local` — прямое подключение к файлу БД через `DatabaseConnector` (`src/database_connector.py`).
- `remote` — прямое сетевое подключение к серверу Firebird через `RemoteDatabaseConnector` (`src/remote_db_connector.py`, READ‑ONLY, валидация SQL внутри).
- Графический интерфейс (`src/gui_app.py`) переключает режимы через `Radiobutton` и использует `isinstance(self.db_connector, RemoteDatabaseConnector)` для выбора логики загрузки данных.
- Выбор магазинов, генерация отчетов и экспорт в Excel завязаны на pandas DataFrame, которые возвращают коннекторы.

### 1.2. Новый доступный канал
- Есть готовый REST API (`ИНСТРУКЦИЯ_ДЛЯ_ПРИЛОЖЕНИЙ.md`).
- Базовый URL по умолчанию: `http://85.114.224.45:8000` (может отличаться, нужно хранить в конфиге).
- Аутентификация: `Authorization: Bearer <токен>`, токены уникальны.
- Доступны эндпоинты: `/api/query`, `/api/tables`, `/api/schema/{name}`, `/api/health`.
- API 100 % READ‑ONLY, контролирует SQL (разрешены только `SELECT`/`WITH`).
- Возвращает JSON с полями `success`, `data`, `rows_count`, `execution_time`, `error`.

### 1.3. Важные ограничения
- Нельзя ломать существующие методы `DatabaseConnector` (они используются для локального режима).
- Нельзя модифицировать прямой доступ к Firebird (remote) без крайней необходимости.
- Все изменения должны быть обратимыми и минимально инвазивными.
- Все SQL запросы для API должны оставаться только на чтение.

---

## 2. Зоны изменений

| Зона | Файл(ы) | Что нужно сделать |
|------|---------|-------------------|
| Конфигурация | `config/` | Добавить новый `.env` для API (URL + токен), обновить пример и `.gitignore`. |
| Коннекторы | `src/` | Создать новый класс (например, `ProxyApiConnector`) с тем же публичным интерфейсом, что использует GUI (минимум: `test_connection()`, `execute_query_to_dataframe()`, `get_stores_info()`/аналог, `get_coffee_sales_with_packages()` или вспомогательные методы). |
| GUI | `src/gui_app.py` | Добавить третий режим (`proxy`), настроить UI для ввода URL и токена, адаптировать проверку типов, обновить логику загрузки магазинов и отчета. |
| Логи/ошибки | `src/logger_config.py`, GUI | Убедиться, что ошибки API логируются понятным образом (не выводим токены!). |
| Скрипты и тесты | `scripts/`, `tests/` | Добавить тестовый скрипт `test_proxy_connection.py` или аналог, продумать юнит/интеграционные тесты (по возможности с моками). |
| Документация | `README.md`, `docs/` | Зафиксировать новый режим в пользовательской и тех. документации. |

---

## 3. Пошаговый план внедрения

### Этап 0. Предварительная подготовка
1. ✅ Прочитать `ИНСТРУКЦИЯ_ДЛЯ_ПРИЛОЖЕНИЙ.md` (сделано).
2. Зафиксировать актуальный токен и URL (получить у администратора, не коммитить в репозиторий).
3. Создать резервную ветку/копию проекта (на уровень Git).

### Этап 1. Конфигурация
1. Создать `config/proxy_api.env.example` с переменными:
   - `PROXY_API_URL`
   - `PROXY_API_TOKEN`
   - `PROXY_API_TIMEOUT`
   - `PROXY_API_MAX_RETRIES`
2. Добавить `config/proxy_api.env` в `.gitignore` (если ещё не добавлен).
3. Подготовить загрузку новых переменных (либо через `dotenv`, либо отдельный модуль конфигурации).

### Этап 2. Новый коннектор
1. Создать `src/proxy_api_connector.py` со следующей логикой:
   - Использовать `requests.Session` с retry.
   - Заголовки: `Authorization`, `Content-Type`.
   - Методы:
     - `test_connection()` → `GET /api/health`.
     - `execute_query_to_dataframe(query, params=None)` → POST `/api/query`, преобразование `data` → `pd.DataFrame`.
     - `get_tables()`, `get_table_schema()` (опционально, если нужно).
     - `get_coffee_sales_with_packages(...)` — реализовать на основе существующей SQL‑логики (используем те же запросы, что и `_get_remote_sales_data`, но выполняем через API). Чтобы минимизировать изменения в GUI, лучше вернуть DataFrame с колонками как у локальной реализации (`STORE_NAME`, `ORDER_DATE`, `AllCup`/`PACKAGES_KG`/`TOTAL_CASH`).
   - Обработка ошибок: логирование, исключения с понятными сообщениями, retry при `429` (rate limit).
   - Никогда не логировать полный токен.
2. Подумать о базовом интерфейсе (например, ABC), но можно ограничиться совпадением методов, которые использует GUI.

### Этап 3. Подключение коннектора к GUI
1. Обновить `src/gui_app.py`:
   - Добавить третий радиобаттон `Удаленная БД (через API)`.
   - Показать отдельный фрейм с полями: `API URL`, `API Token` (с `show='*'`), таймаут/повторные попытки (опционально).
   - Переписать `connect_to_db()`:
     - При выборе `proxy` создавать `ProxyApiConnector`.
     - `test_connection()` должен вызывать `GET /api/health` и показать понятное сообщение об ошибке.
     - При успехе показывать статус «Подключено (API)».
   - В `disconnect_from_db()` корректно закрывать HTTP‑сессию (`session.close()`).
2. Адаптировать логические ветки:
   - `load_stores()` — для API нужно вызывать `execute_query_to_dataframe` или отдельный метод, как для remote.
   - `generate_report()` — вместо проверки `isinstance(..., RemoteDatabaseConnector)` использовать что‑то вроде `self._is_remote_like_connector()` или список типов `(RemoteDatabaseConnector, ProxyApiConnector)`.
   - `_get_remote_sales_data()` — сделать более универсальной (принимать коннектор как аргумент) или создать новую `_get_proxy_sales_data()` с той же логикой (выполнение SQL → DataFrame через API). Обсудить, возможно ли объединить код, чтобы не дублировать SQL.
3. Гарантировать, что старое поведение (локальное + прямое удалённое) не изменилось.

### Этап 4. Тестирование
1. Написать/обновить скрипт `scripts/test_proxy_connection.py`:
   - Загружает `.env`, вызывает `test_connection()`, выполняет несколько SELECT.
   - Проверяет основные сценарии и ловит ошибки (в том числе неверный токен).
2. Ручное тестирование GUI:
   - Подключиться к API режиму (валидный токен).
   - Загрузить список магазинов.
   - Сформировать отчёт за короткий период.
   - Сравнить результаты с локальной/прямой удалённой БД (для верификации).
3. Проверить обработки ошибок:
   - Неверный токен.
   - Неверный URL.
   - Rate limit (при необходимости, можно смоделировать повышенными запросами).

### Этап 5. Документация и уборка
1. Добавить описание нового режима в:
   - `README.md` (раздел «Режимы подключения»).
   - `ИНСТРУКЦИЯ_ДЛЯ_ПРИЛОЖЕНИЙ.md` (ссылка на клиентскую реализацию).
   - Создать/обновить быстрые инструкции для пользователей GUI.
2. Зафиксировать инструкции по выдаче токенов (кто/как).
3. Пройтись по логам и убедиться, что нет чувствительных данных.

---

## 4. Технические заметки и проверки

- **Совместимость DataFrame:**
  - Локальный режим возвращает колонки `STORE_NAME`, `ORDER_DATE`, `MonoCup`, `BlendCup`, `CaotinaCup`, `AllCup`, `PACKAGES_KG`, `TOTAL_CASH`.
  - Удалённый режим через `_get_remote_sales_data` возвращает `ALLCUP`, `PACKAGES_KG`, `TOTAL_CASH` (прописные). Приравнивание делается в `generate_report()` (переименование). Новый коннектор должен выдавать совместимые колонки, чтобы переименование отрабатывало.

- **Секреты:**
  - Все токены в `.env`, не коммитим.
  - В логах маскировать токен (например, выводить `token[:4] + '***'`).

- **Timeouts и retry:**
  - Подобрать разумные значения (например, `timeout=30`, `max_retries=3`).
  - При `429 Too Many Requests` делать backoff (5–10 сек) и информировать пользователя.

- **Код-стайл:**
  - Использовать `requests.Session` с `HTTPAdapter(Retry(...))`.
  - Возвращать DataFrame через `pd.DataFrame(response['data'])`, при отсутствии данных — пустой DataFrame с нужными колонками.

- **Абстракция:**
  - Возможно, стоит добавить протокольный тип `SupportsDataFrameConnector` или общий базовый класс, но это можно сделать позже. Главное — не ломать существующие интерфейсы.

---

## 5. Разбиение по микро-задачам (для постепенного внедрения)

1. **Подготовка**
   - [ ] Создать ветку `feature/gui-proxy-api`.
   - [ ] Скопировать токен в `config/proxy_api.env` (локально).

2. **Конфигурация**
   - [ ] Добавить `.env.example` и обновить `.gitignore`.
   - [ ] Подготовить загрузку переменных (через `dotenv`).

3. **Коннектор**
   - [ ] Создать `ProxyApiConnector`.
   - [ ] Реализовать `test_connection()`.
   - [ ] Реализовать `execute_query_to_dataframe()`.
   - [ ] Реализовать `get_stores_dataframe()` (SELECT ID, NAME ...).
   - [ ] Реализовать `get_sales_data()` (SQL тот же, что у `_get_remote_sales_data`).

4. **GUI**
   - [ ] Добавить UI для третьего режима.
   - [ ] Подключить `ProxyApiConnector` в `connect_to_db()`.
   - [ ] Унифицировать `load_stores()` и `generate_report()` (учесть `ProxyApiConnector`).
   - [ ] Переписать `_get_remote_sales_data()` на общий хелпер.

5. **Тесты и проверка**
   - [ ] Написать `scripts/test_proxy_connection.py`.
   - [ ] Запустить и задокументировать результат.
   - [ ] Ручное тестирование GUI (скриншоты + заметки).

6. **Документация**
   - [ ] Обновить `README.md`.
   - [ ] Дополнить `ИНСТРУКЦИЯ_ДЛЯ_ПРИЛОЖЕНИЙ.md` (ссылка на новый коннектор).
   - [ ] Создать краткую инструкцию для пользователей GUI.

---

## 6. Контрольный список перед слиянием

- [ ] Локальные, удалённые и API режимы работают независимо.
- [ ] Все тестовые запросы — только `SELECT`/`WITH`.
- [ ] При ошибках API пользователь получает понятные сообщения.
- [ ] Токены нигде не записываются в логи.
- [ ] Нет жёстко прописанных секретов в коде.
- [ ] Документация обновлена.
- [ ] План ручного регресса выполнен.

---

## 7. Дополнительные идеи (на будущее)

- Вынести общую логику работы с «удалённым прочтением» в абстрактный класс (например, `BaseReadOnlyConnector`).
- Добавить кеширование частых запросов на стороне клиента (например, список магазинов).
- Сделать автоматическую проверку токена при запуске приложения (health check).
- Добавить сбор метрик (время ответа API, количество попыток) в логи.

---

**Документ подготовлен для пошаговой реализации интеграции.**  
Используйте его как чек-лист и контекст при дальнейших изменениях.

